package org.jdbi.generator.templates;

import org.jdbi.generator.explorer.DBColumn;
import org.jdbi.generator.explorer.DBConnection;
import org.jdbi.generator.explorer.DBTable;
import org.jdbi.generator.main.AbstractComponent;
import org.jdbi.generator.main.Workspace;
import org.jdbi.generator.utils.Files;
import org.jdbi.generator.utils.Resources;
import org.jdbi.generator.utils.Strings;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;


public abstract class AbstractTemplate extends AbstractComponent
{
    protected Workspace workspace;
    protected List<DBTable> tables;

    private static final Set<String> filterTypes = new HashSet<String>()
    {{
        add( Boolean.class.getName() );
        add( Character.class.getName() );
        add( Byte.class.getName() );
        add( Short.class.getName() );
        add( Integer.class.getName() );
        add( Long.class.getName() );
        add( Float.class.getName() );
        add( Double.class.getName() );
        add( BigInteger.class.getName() );
        add( BigDecimal.class.getName() );
        add( String.class.getName() );
        add( java.util.Date.class.getName() );
        add( java.sql.Date.class.getName() );
        add( Time.class.getName() );
        add( Timestamp.class.getName() );
    }};


    protected AbstractTemplate(Workspace workspace, List<DBTable> tables)
    {
        super();
        setWorkspace( workspace );
        setTables( tables );
    }


    protected abstract String getSource(int index, DBTable dbTable);
    protected abstract String getTarget(int index, DBTable dbTable);
    protected abstract void preMapping(StringBuilder template);
    protected abstract Map<String, Object> getMapping(int index, DBTable dbTable);
    public abstract void generate() throws Exception;


    protected Workspace getWorkspace()
    {
        return workspace;
    }

    protected void setWorkspace(Workspace workspace)
    {
        this.workspace = workspace;
    }


    protected List<DBTable> getTables()
    {
        return tables;
    }

    protected void setTables(List<DBTable> tables)
    {
        this.tables = tables;
    }


    protected String getDataSourcePropertiesName()
    {
        return workspace.getDataSourceName().replace("_","-").toLowerCase();
    }


    protected boolean isAutoGenerated(DBColumn dbColumn)
    {
        return (dbColumn.isAutoIncrement() || dbColumn.isGenerated());
    }


    private void addImport(String imp, List<String> imports)
    {
        if (imp != null)
            if (imports != null)
                if (!imports.contains(imp))
                    imports.add(imp);
    }

    protected String getNormalizedType(String type, List<String> imports)
    {
        if (Character.class.getName().equals(type)
            ||
            char[].class.getName().equals(type))
        {
            type = String.class.getSimpleName();
        }
        else
        if (BigInteger.class.getName().equals(type))
        {
            type = Long.class.getSimpleName();
        }
        else
        if (BigDecimal.class.getName().equals(type))
        {
            type = BigDecimal.class.getSimpleName();
            addImport(BigDecimal.class.getName(), imports);
            return type;
        }
        else
        if (java.util.Date.class.getName().equals(type))
        {
            type = java.util.Date.class.getSimpleName();
            addImport(java.util.Date.class.getName(), imports);
            return type;
        }
        else
        if (java.sql.Date.class.getName().equals(type))
        {
            if (bool(workspace.getTimestampsLikeDates()))
            {
                type = java.util.Date.class.getSimpleName();
                addImport(java.util.Date.class.getName(), imports);
            }
            else
            {
                type = java.sql.Date.class.getSimpleName();
                addImport(java.sql.Date.class.getName(), imports);
            }

            return type;
        }
        else
        if (Timestamp.class.getName().equals(type))
        {
            if (bool(workspace.getTimestampsLikeDates()))
            {
                type = java.util.Date.class.getSimpleName();
                addImport(java.util.Date.class.getName(), imports);
            }
            else
            {
                type = Timestamp.class.getSimpleName();
                addImport(Timestamp.class.getName(), imports );
            }

            return type;
        }
        else
        if (Time.class.getName().equals(type))
        {
            if (bool(workspace.getTimestampsLikeDates()))
            {
                type = java.util.Date.class.getSimpleName();
                addImport(java.util.Date.class.getName(), imports);
            }
            else
            {
                type = Time.class.getSimpleName();
                addImport(Time.class.getName(), imports);
            }
        }
        else
        if (java.sql.Clob.class.getName().equals(type)
            ||
            java.sql.NClob.class.getName().equals(type))
        {
            type = String.class.getSimpleName();
            return type;
        }
        else
        if (java.sql.Blob.class.getName().equals(type))
        {
            type = DBConnection.BYTE_ARRAY_CLASS_NAME;
            return type;
        }

        type = type.replace("java.lang.", "");

        return type;
    }


    protected boolean isFilterType(DBColumn dbColumn)
    {
        if (dbColumn.isJson() || dbColumn.isJsonB())
            return false;
        else
            return filterTypes.contains(dbColumn.getClassName());
    }


    protected boolean isIntegerType(DBColumn dbColumn)
    {
        return (dbColumn.getClassName().equals(Byte.class.getName())
                ||
                dbColumn.getClassName().equals(Short.class.getName())
                ||
                dbColumn.getClassName().equals(Integer.class.getName())
                ||
                dbColumn.getClassName().equals(Long.class.getName()));
    }


    protected String getColumnComment(DBColumn dbColumn)
    {
        String comment = "";

        if (dbColumn.getClassName().equals(String.class.getName()))
            comment += "(" + Strings.toSpaceSize(dbColumn.getSize()) + ")";
        else
        if (dbColumn.getClassName().equals(DBConnection.BYTE_ARRAY_CLASS_NAME))
            comment += "(" + Strings.toSpaceSize(dbColumn.getSize()) + ")";

        if (dbColumn.isPrimaryKey())
            comment += " (pk)";

        if (dbColumn.isGenerated())
            comment += " (generated)";

        if (dbColumn.isAutoIncrement())
            comment += " (auto)";

        if (dbColumn.isUniqueKey())
            comment += " (unique)";

        if (!dbColumn.isNullable())
            comment += " (required)";

        if (dbColumn.isEncrypted())
            comment += " (encrypted)";

        if (isNotEmpty(dbColumn.getForeignKey()))
            comment += " (fk -> " + dbColumn.getForeignTable() + "."  + dbColumn.getForeignKey() + ")";

        return comment;
    }


    protected void generate(int index, DBTable dbTable) throws Exception
    {
        String source = getSource(index, dbTable);

        if (isNullOrEmpty(source))
            return;

        String target = getTarget(index, dbTable);

        if (isNullOrEmpty(target))
            return;

        StringBuilder template = Files.readStream( Resources.getResourceAsStream(source) );

        preMapping( template );

        Map<String, Object> mapping = getMapping(index, dbTable);

        if (isNotEmpty(mapping))
            FreemarkerTemplates.getInstance().process(source, template, mapping);

        Files.writeFile(template.toString(), target);
    }


    protected void generate(int index) throws Exception
    {
        generate(index, null);
    }

}

